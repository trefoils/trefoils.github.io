<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络编程基础 | Trefoil</title>
    <meta name="generator" content="VuePress 1.5.3">
    
    <meta name="description" content="井底之蛙，怎知天大。孤峰之脚，方知人小">
    <link rel="preload" href="/assets/css/0.styles.08f75515.css" as="style"><link rel="preload" href="/assets/js/app.f41c39d2.js" as="script"><link rel="preload" href="/assets/js/2.0f0c28b9.js" as="script"><link rel="preload" href="/assets/js/32.a0a01885.js" as="script"><link rel="prefetch" href="/assets/js/10.7b14cb97.js"><link rel="prefetch" href="/assets/js/11.f683145f.js"><link rel="prefetch" href="/assets/js/12.6b8958ab.js"><link rel="prefetch" href="/assets/js/13.dcd7c486.js"><link rel="prefetch" href="/assets/js/14.0e64ef68.js"><link rel="prefetch" href="/assets/js/15.3738b4ad.js"><link rel="prefetch" href="/assets/js/16.6d2a0b84.js"><link rel="prefetch" href="/assets/js/17.d3e472d1.js"><link rel="prefetch" href="/assets/js/18.7f325e10.js"><link rel="prefetch" href="/assets/js/19.81a2113b.js"><link rel="prefetch" href="/assets/js/20.8a409f80.js"><link rel="prefetch" href="/assets/js/21.84d42972.js"><link rel="prefetch" href="/assets/js/22.64df382b.js"><link rel="prefetch" href="/assets/js/23.b2b57a37.js"><link rel="prefetch" href="/assets/js/24.dbe1f212.js"><link rel="prefetch" href="/assets/js/25.536f91b6.js"><link rel="prefetch" href="/assets/js/26.8919ff36.js"><link rel="prefetch" href="/assets/js/27.8078dabf.js"><link rel="prefetch" href="/assets/js/28.79cf8b47.js"><link rel="prefetch" href="/assets/js/29.d528e890.js"><link rel="prefetch" href="/assets/js/3.7e03a49a.js"><link rel="prefetch" href="/assets/js/30.953c29ea.js"><link rel="prefetch" href="/assets/js/31.7ba64e73.js"><link rel="prefetch" href="/assets/js/33.40b7751b.js"><link rel="prefetch" href="/assets/js/34.de2fb230.js"><link rel="prefetch" href="/assets/js/4.a66dc1e8.js"><link rel="prefetch" href="/assets/js/5.f0631bf8.js"><link rel="prefetch" href="/assets/js/6.efdee8bf.js"><link rel="prefetch" href="/assets/js/7.9c013080.js"><link rel="prefetch" href="/assets/js/8.33e59ac7.js"><link rel="prefetch" href="/assets/js/9.f2c1974a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.08f75515.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Trefoil</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  前端面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专业课" class="dropdown-title"><span class="title">专业课</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/study/infomation-safe/" class="nav-link">
  信息安全
</a></li><li class="dropdown-item"><!----> <a href="/study/network/" class="nav-link router-link-active">
  网络编程
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/trefoils/Blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  博客
</a></div><div class="nav-item"><a href="/interview/" class="nav-link">
  前端面试题
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="专业课" class="dropdown-title"><span class="title">专业课</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/study/database/" class="nav-link">
  数据库
</a></li><li class="dropdown-item"><!----> <a href="/study/infomation-safe/" class="nav-link">
  信息安全
</a></li><li class="dropdown-item"><!----> <a href="/study/network/" class="nav-link router-link-active">
  网络编程
</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">
  关于
</a></div> <a href="https://github.com/trefoils/Blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>网络编程</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/study/network/basic/basic.html" aria-current="page" class="active sidebar-link">网络编程基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_1-网络编程与进程通信" class="sidebar-link">1.网络编程与进程通信</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_2-网络应用进程在网络体系结构中的位置" class="sidebar-link">2.网络应用进程在网络体系结构中的位置</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_3-实现网间进程通信必须解决的问题" class="sidebar-link">3.实现网间进程通信必须解决的问题</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_4-internet中网间进程的标识" class="sidebar-link">4.Internet中网间进程的标识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#传输层在网络通信中的地位" class="sidebar-link">传输层在网络通信中的地位</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#端口的概念" class="sidebar-link">端口的概念</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#端口号的分配机制" class="sidebar-link">端口号的分配机制</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#进程的网络地址的概念" class="sidebar-link">进程的网络地址的概念</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#网络中进程通信的标识" class="sidebar-link">网络中进程通信的标识</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_5-网络协议的特征" class="sidebar-link">5.网络协议的特征</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#面向消息的协议" class="sidebar-link">面向消息的协议</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#基于流的协议" class="sidebar-link">基于流的协议</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#面向连接的服务" class="sidebar-link">面向连接的服务</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#面向无连接的服务" class="sidebar-link">面向无连接的服务</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#可靠性和次序性" class="sidebar-link">可靠性和次序性</a></li></ul></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_6-高效的用户数据报协议-udp" class="sidebar-link">6.高效的用户数据报协议(UDP)</a></li><li class="sidebar-sub-header"><a href="/study/network/basic/basic.html#_7-可靠的传输控制协议-tcp" class="sidebar-link">7.可靠的传输控制协议(TCP)</a></li></ul></li><li><a href="/study/network/cs-mode/cs-mode.html" class="sidebar-link">客户机/服务器交互模式(C/S)</a></li><li><a href="/study/network/p2p-mode/p2p-mode.html" class="sidebar-link">P2P模式</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="网络编程基础"><a href="#网络编程基础" class="header-anchor">#</a> 网络编程基础</h1> <h2 id="_1-网络编程与进程通信"><a href="#_1-网络编程与进程通信" class="header-anchor">#</a> 1.网络编程与进程通信</h2> <p><strong>进程与线程的基本概念</strong></p> <p>进程是操作系统理论中最重要的概念之一，简单地说，进程是处于运行过程中的程序实例，是操作系统调度和分配资源的基本单位。</p> <p>一个进程实体由程序代码、数据和进程控制块3部分构成。程序代码规定了进程所做的计算；数据是计算的对象；进程控制块是操作系统内核为了控制进程所建立的数据结构，是操作系统用来管理进程的内核对象，也是系统用来存放关于进程的统计信息的地方。系统给进程分配一个地址空间，用来装入进程的所有可执行模块或动态链接库（Dynamic Linking Library，DLL）模块的代码和数据。进程还包含动态分配的内存空间，如线程堆栈和堆分配空间。多个进程可以在操作系统的协调下，在内存中并发地运行。</p> <p>各种计算机应用程序在运行时，都以进程的形式存在，网络应用程序也不例外。在Windows操作系统中，可以同时打开多个浏览器的窗口访问多个网站，同时运行Foxmail电子邮件程序查看自己的邮箱，同时使用迅雷下载文件，它们都会在Windows桌面上打开一个窗口。每一个窗口中运行的网络应用程序，都是一个网络应用进程。网络编程就是要开发网络应用程序，所以了解进程的概念是非常重要的。</p> <p>Windows系统不但支持多进程，还支持多线程。在Windows系统中，进程是分配资源的单位，但不是执行和调度资源的单位。进程若要完成某项操作，它必须拥有一个在它的环境中运行的线程，该线程负责执行包含在进程的地址空间中的代码。实际上，单个进程可能包含若干个线程，所有这些线程都“同时”执行进程地址空间中的代码。为此，每个线程都有它自己的一组CPU寄存器和它自己的堆栈。每个进程至少拥有一个线程，来执行进程的地址空间中的代码。如果没有线程，那么进程就没有存在的理由了，系统就会自动撤销该进程和它的地址空间。若要使所有这些线程都能运行，操作系统就要为每个线程安排一定的CPU时间。它通过一种循环方式为线程提供时间片（称为量程quantum），造成一种假象，仿佛所有线程都是同时运行的一样。</p> <p>当创建一个进程时，系统会自动创建它的第一个线程，称为主线程。然后，该线程可以创建其他的线程，而这些线程又能创建更多的线程。</p> <h2 id="_2-网络应用进程在网络体系结构中的位置"><a href="#_2-网络应用进程在网络体系结构中的位置" class="header-anchor">#</a> 2.网络应用进程在网络体系结构中的位置</h2> <p>从功能上，可以将网络应用程序分为两部分。</p> <ul><li>一部分是专门负责网络通信的模块，它们与网络协议栈相连接，借助网络协议栈提供的服务完成网络上数据信息的交换；</li> <li>另一部分是面向用户或者进行其他处理的模块，它们接收用户的命令，或者对借助网络传输过来的数据进行加工。</li></ul> <p>由此可见，网络编程首先要解决网间进程通信的问题，然后才能在通信的基础上开发各种应用功能。</p> <h2 id="_3-实现网间进程通信必须解决的问题"><a href="#_3-实现网间进程通信必须解决的问题" class="header-anchor">#</a> 3.实现网间进程通信必须解决的问题</h2> <p>网间进程通信是指网络中不同主机中的应用进程之间的相互通信，当然，可以把同机进程间的通信看作是网间进程通信的特例。网间进程通信必须解决以下问题。</p> <ul><li><p>网间进程的标识问题。在同一主机中，不同的进程可以用进程号（ProcessID）唯一标识。但在网络环境下，各主机独立分配的进程号已经不能唯一地标识一个进程。例如，主机A中某进程的进程号是5，在B机中也可以存在5号进程，进程号不再唯一了，因此，在网络环境下，仅仅说“5号进程”就没有意义了。</p></li> <li><p>与网络协议栈连接的问题。网间进程的通信实际是借助网络协议栈实现的。应用进程把数据交给下层的传输层协议实体，调用传输层提供的传输服务，传输层及其下层协议将数据层层向下递交，最后由物理层将数据变为信号，发送到网上，经过各种网络设备的寻径和存储转发，才能到达目的端主机，目的端的网络协议栈再将数据层层上传，最终将数据送交接收端的应用进程，这个过程是非常复杂的。但是对于网络编程来说，必须要有一种非常简单的方法，来与网络协议栈连接。这个问题是通过定义Socket网络编程接口来解决的。</p></li> <li><p>多重协议的识别问题。现行的网络体系结构有很多，如TCP/IP、IPX/SPX等，操作系统往往支持众多的网络协议。不同协议的工作方式不同，地址格式也不同，因此网间进程通信还要解决多重协议的识别问题。</p></li> <li><p>不同的通信服务的问题。随着网络应用的不同，网间进程通信所要求的通信服务也会有所不同。例如，文件传输服务，传输的文件可能很大，要求传输非常可靠、无差错、无乱序、无丢失；下载了一个程序，如果丢了几个字节，这个程序可能就不能用了。但对于网上聊天这样的应用，要求就不高。因此，要求网络应用程序能够有选择地使用网络协议栈提供的网络通信服务功能。在TCP/IP协议簇中，传输层有TCP和UDP这两个协议，TCP提供可靠的数据流传输服务，UDP提供不可靠的数据报传输服务。深入了解它们的工作机制，对于网络编程是非常必要的。</p></li></ul> <h2 id="_4-internet中网间进程的标识"><a href="#_4-internet中网间进程的标识" class="header-anchor">#</a> 4.Internet中网间进程的标识</h2> <p>基于TCP/IP协议栈的进程之间的通信情况，如图所示：</p> <p><img src="/images/study/network/basic.jpeg" alt="images"></p> <h3 id="传输层在网络通信中的地位"><a href="#传输层在网络通信中的地位" class="header-anchor">#</a> 传输层在网络通信中的地位</h3> <p>Internet是基于TCP/IP协议栈的，TCP/IP协议栈的特点是两头大、中间小。在应用层，有众多的应用进程，分别使用不同的应用层协议；在网络接口层，有多种数据链路层协议，可以和各种物理网相接；在网络层，只有一个IP实体。在发送端，所有上层的应用进程的信息都要汇聚到IP层；在接收端，下层的信息又从IP层分流到不同的应用进程。</p> <p>网络层的IP，在Internet中起着非常重要的作用。它用IP地址统一了Internet中各种主机的物理地址，用IP数据报统一了各种物理网的帧，实现了异构网的互连。粗略地说，在Internet中，每一台主机都有一个唯一的IP地址，利用IP地址可以唯一地定位Internet中的一台计算机，实现计算机之间的通信。但是最终进行网络通信的不是整个计算机，而是计算机中的某个应用进程。每个主机中有许多应用进程，仅有IP地址是无法区别一台主机中的多个应用进程的。从这个意义上讲，网络通信的最终地址就不仅仅是主机的IP地址了，还必须包括可以描述应用进程的某种标识符。</p> <p>按照OSI 7层协议的描述，传输层与网络层在功能上的最大区别是<code>传输层提供进程通信的能力</code>。TCP/IP提出了传输层协议端口（Protocol Port）的概念，成功地解决了通信进程的标识问题。</p> <p>传输层是计算机网络中通信主机内部进行独立操作的第1层，是支持端到端的进程通信的关键的一层。如上图所示，应用层的多个进程通过各自的端口复用TCP或UDP，TCP或UDP再复用网络层的IP，经过通信子网的存储转发，将数据传送到目的端的主机。而在目的端主机中，IP将数据分发给TCP或UDP，再由TCP或UDP通过特定的端口传送给相应的进程。对于网络协议栈来说，在发送端是自上而下地复用，在接收端是自下而上地分用，从而实现了网络中应用进程之间的通信。</p> <h3 id="端口的概念"><a href="#端口的概念" class="header-anchor">#</a> 端口的概念</h3> <p>端口是TCP/IP协议簇中，应用层进程与传输层协议实体间的通信接口，在OSI 7层协议的描述中，将它称为应用层进程与传输层协议实体间的服务访问点（SAP）。应用层进程通过系统调用与某个端口进行绑定，然后就可以通过该端口接收或发送数据，因为应用进程在通信时，必须用到一个端口，它们之间有着一一对应的关系，所以可以用端口来标识通信的网络应用进程。</p> <p>类似于文件描述符，每个端口都拥有一个叫作端口号（PortNumber）的整数型标识符，用于区别不同的端口。由于TCP/IP协议簇传输层的两个协议，即TCP和UDP，是完全独立的两个软件模块，因此各自的端口号也相互独立。如TCP有一个255号端口，UDP也可以有一个255号端口，二者并不冲突</p> <p>从实现的角度讲，端口是一种抽象的软件机制，包括一些数据结构和I/O缓冲区。应用程序（即进程）通过系统调用与某端口建立绑定（Binding）关系后，传输层传给该端口的数据都被相应进程接收，相应进程发给传输层的数据都通过该端口输出。在TCP/IP的实现中，端口操作类似于一般的I/O操作，进程获取一个端口，相当于获取本地唯一的I/O文件，可以用一般的读写原语访问它。</p> <h3 id="端口号的分配机制"><a href="#端口号的分配机制" class="header-anchor">#</a> 端口号的分配机制</h3> <p>假如网络中两主机的两个进程甲、乙要通信，并且甲首先向乙发送信息，那么，甲进程必须知道乙进程的地址，包括网络层地址和传输层的端口号。IP地址是全局分配的，能保证全网的唯一性，并且在通信之前，甲就能知道乙的IP地址；但端口号是由每台主机自己分配的，只有本地意义，无法保证全网唯一，所以甲在通信之前是无法知道乙的端口号的。这个问题如何解决呢？</p> <p>由于在Internet的应用程序开发中，大多都采用客户机/服务器（C/S）的模式，在这种模式下，客户机与服务器的通信总是由客户机首先发起，因此只需要让客户机进程事先知道服务器进程的端口号就行了。另一方面，在Internet中，众所周知的为大家所接受的服务是有限的。基于这两方面的考虑，TCP/IP采用了全局分配（静态分配）和本地分配（动态分配）相结合的方法。对TCP或者UDP，将它们的全部65 535个端口号分为保留端口号和自由端口号两部分。</p> <p>保留端口的范围是0～1 023，又称为众所周知的端口或熟知端口（Well-known Port），只占少数，采用全局分配或集中控制的方式，由一个公认的中央机构根据需要进行统一分配，静态地分配给Internet上著名的众所周知的服务器进程，并将结果公布于众。由于一种服务使用一种应用层协议，也可以说把保留端口分配给了一些应用层协议。如下表列举了一些应用层协议分配到的保留端口号。</p> <p><img src="/images/study/network/port.jpeg" alt="images"></p> <p>这样，每一个标准的服务器都拥有了一个全网公认的端口号，在不同的服务器类主机上，使用相同应用层协议的服务器的端口号也相同。例如，所有的3W服务器默认的端口号都是80，FTP服务器默认的端口号都是21。</p> <p>其余的端口号，1024～65535，称为自由端口号，采用本地分配，又称为动态分配的方法，由每台计算机在网络进程通信时，动态地、自由地分配给要进行网络通信的应用层进程。具体地说，当需要访问传输层服务时，应用进程向本地操作系统提出申请，操作系统返回一个本地唯一的端口号，进程再通过合适的系统调用将自己与该端口号联系起来（绑定），然后通过它进行网络通信。</p> <p>具体来说，TCP或UDP端口的分配规则如下。</p> <ul><li>端口0：不使用或者作为特殊的用途。</li> <li>端口1～255：保留给特定的服务。TCP和UDP均规定，小于256的端口号才能分配给网上众所周知的服务。</li> <li>端口256～1023：保留给其他的服务，如路由。</li> <li>端口1024～4999：可以用作任意客户机的端口。</li> <li>端口5000～65535：可以用作用户的服务器端口。</li></ul> <div class="custom-block tip"><p class="custom-block-title">服务器进程是怎么为多个客户机进程服务的</p> <p>如果当某个客户机第一次成功地连接到服务器后，服务器就接着用这个保留端口继续与该客户机通信，那么其他申请连接的客户机就只能等待了，这就无法实现服务器进程同时为多个客户机服务的要求。但实际的情况是，一个网站的WWW服务器，可以同时为千百个人服务，这是怎么回事呢？原来，在TCP/IP的端口号分配机制中，服务器的保留端口是专门用来监听客户端的连接请求的，当服务器从保留端口收到一个客户机的连接请求后，立即创建另外一个线程，并为这个线程分配一个服务器端的自由端口号，然后用这个线程继续与那个客户机进行通信；而服务器的保留端口就又可以接收另一个客户机的连接请求了，这就是所谓“偷梁换柱”的办法。</p></div> <h3 id="进程的网络地址的概念"><a href="#进程的网络地址的概念" class="header-anchor">#</a> 进程的网络地址的概念</h3> <p>网络通信中通信的两个进程分别处在不同的计算机上。在Internet中，两台主机可能位于不同的网络中，这些网络通过网络互连设备（网关、网桥和路由器等）连接。因此要在Internet中定位一个应用进程，需要以下三级寻址。</p> <ol><li>某一主机总是与某个网络相连，必须指定主机所在的特定网络地址，称为网络ID。</li> <li>网络上每一台主机应有其唯一的地址，称为主机ID。</li> <li>每一主机上的每一应用进程应有在该主机上的唯一标识符。</li></ol> <p>在 <strong>TCP/IP</strong> 中，<code>主机IP地址</code>就是由 <code>网络ID</code> 和 <code>主机ID</code> 组成的，IPv4中用32位二进制数值表示；<strong>应用进程</strong> 是用TCP或UDP的16位端口号来标识的。</p> <p>综上所述，在Internet中，用一个三元组可以在全局中唯一地标识一个应用层进程。</p> <div class="language- extra-class"><pre class="language-text"><code>应用层进程 =（传输层协议，主机的IP地址，传输层的端口号）
</code></pre></div><p>这样一个三元组，叫作一个半相关（Half-association），它标识了Internet中进程间通信的一个端点，也把它称为进程的网络地址。</p> <h3 id="网络中进程通信的标识"><a href="#网络中进程通信的标识" class="header-anchor">#</a> 网络中进程通信的标识</h3> <p>在Internet中，一个完整的网间进程通信需要由两个进程组成，两个进程是通信的两个端点，并且只能使用同一种传输层协议。也就是说，不可能通信的一端用TCP，而另一端用UDP。因此一个完整的网间通信需要一个五元组在全局中唯一地来标识。</p> <div class="language- extra-class"><pre class="language-text"><code>【传输层协议，本地机IP地址，本地机传输层端口，远地机IP地址，远地机传输层端口】
</code></pre></div><p>这个五元组称为一个全相关（Association），即两个协议相同的半相关才能组合成一个合适的全相关，或完全指定一对网间通信的进程。</p> <h2 id="_5-网络协议的特征"><a href="#_5-网络协议的特征" class="header-anchor">#</a> 5.网络协议的特征</h2> <p>在OSI的术语中，网络层及其以下各层又称为通信子网，只提供点到点通信，没有程序或进程的概念。而传输层实现的是“端到端”通信，引进了网间进程通信的概念，同时也要解决差错控制、流量控制、报文排序和连接管理等问题，为此，传输层以不同的方式向应用层提供不同的服务。</p> <h3 id="面向消息的协议"><a href="#面向消息的协议" class="header-anchor">#</a> 面向消息的协议</h3> <p>面向消息的协议。面向消息的协议以消息为单位在网上传送数据，消息在发送端一条一条地发送，在接收端也只能一条一条地接收，每一条消息是独立的，消息之间存在着边界。例如，如下图，甲工作站向乙工作站发送了3条消息，分别是128字节、64字节和32字节；乙作为接收端，尽管缓冲区是256字节，足以接收甲的3条消息，而且这3条消息已经全部到达了乙的缓冲区，乙仍然必须发出3条读取命令，分别返回128字节、64字节和32字节这3条消息，而不能用一次读取调用来返回这3个数据包，这称为“保护消息边界”（Preserving MessageBoundaries）。保护消息边界是指传输协议把数据当作一条独立的消息在网上传输，接收端只能接收独立的消息。也就是说，存在保护消息边界，接收端一次只能接收发送端发出的一个数据包。UDP就是面向消息的。面向消息的协议适于交换结构化数据，网络游戏就是一个好例子。玩家们交换的是一个个带有地图信息的数据包。</p> <p><img src="/images/study/network/info-proto.jpeg" alt="images"></p> <h3 id="基于流的协议"><a href="#基于流的协议" class="header-anchor">#</a> 基于流的协议</h3> <p>基于流的协议不保护消息边界，将数据当作字节流连续地传输，不管实际消息边界是否存在。如果发送端连续发送数据，接收端有可能在一次接收动作中接收两个或者更多的数据包。在发送端，允许系统将原始消息分解成几条小消息分别发送，或把几条消息积累在一起，形成一个较大的数据包，一次送出。多次发送的数据统一编号，从而把它们联系在一起。接收端会尽量地读取有效数据。只要数据一到达，网络堆栈就开始读取它，并将它缓存下来等候进程处理。在进程读取数据时，系统尽量返回更多的数据。在下图中，甲发送了3个数据包，分别是128字节、64字节和32字节；甲的网络堆栈可以把这些数据聚合在一起，分两次发送出去。是否将各个独立的数据包累积在一起，受许多因素的影响，如网络允许的最大传输单元和发送的算法。在接收端，乙的网络堆栈把所有进来的数据包聚集在一起，放入堆栈的缓冲区，等待应用进程读取。进程发出读的命令，并指定了进程的接收缓冲区，如果进程的缓冲区有256字节，系统马上就会返回全部224（128 + 64 + 32）字节。如果接收端只要求读取20字节，系统就会只返回20字节。TCP是基于流的协议。</p> <p><img src="/images/study/network/net-proto1.jpeg" alt="images"></p> <p>流传输，把数据当作一串数据流，不认为数据是一个一个的消息。但是有很多人在使用TCP通信时，并不清楚TCP是基于流的传输，当连续发送数据的时候，他们认为TCP会丢包。其实不然，因为当使用的缓冲区足够大时，就有可能会一次接收到两个甚至更多的数据包，</p> <h3 id="面向连接的服务"><a href="#面向连接的服务" class="header-anchor">#</a> 面向连接的服务</h3> <p>面向连接的服务是电话系统服务模式的抽象，即每一次完整的数据传输都要经过建立连接、使用连接和终止连接的过程。在数据传输过程中，各数据分组不携带目的地址，而使用连接号（Connect ID）。本质上，连接是一个管道，收发数据不但顺序一致，而且内容相同。TCP提供面向连接的虚电路传输服务，使用面向连接的协议，在进行数据交换之前，通信的对等实体必须进行握手，相互传送连接信息，这一方面确定了通信的路径，另一方面还可以相互协商，做好通信的准备，如准备收发的缓冲区，从而保证通信双方都是活动的，可彼此响应。建立连接需要很多开销，另外，大部分面向连接的协议为了保证投递无误，还要执行额外的计算来验证正确性，这又进一步增加了开销。</p> <h3 id="面向无连接的服务"><a href="#面向无连接的服务" class="header-anchor">#</a> 面向无连接的服务</h3> <p>无连接的服务是邮政系统服务的抽象，每个分组都携带完整的目的地址，各分组在系统中独立传送。无连接的服务不能保证分组到达的先后顺序，不进行分组出错的恢复与重传，不保证传输的可靠性。无连接协议在通信前，不需要建立连接，也不管接收端是否正在准备接收。无连接的服务类似于邮政服务，发信人把信投入邮箱即可；至于收信人是否想收到这封信，或邮局是否会因为暴风雨未能按时将信件投递到收信人处等，发信人都不得而知。UDP就是无连接的协议，提供无连接的数据报传输服务。</p> <h3 id="可靠性和次序性"><a href="#可靠性和次序性" class="header-anchor">#</a> 可靠性和次序性</h3> <p>在设计网络应用程序时，必须了解协议是否能提供可靠性和次序性。可靠性保证了发送端发出的每个字节都能到达既定的接收端，不出错、不丢失、不重复，保证数据的完整性，称为保证投递。次序性是指对数据到达接收端的顺序进行处理。保护次序性的协议保证接收端收到数据的顺序就是数据的发送顺序，称为按序递交。</p> <p>可靠性和次序性与协议是否面向连接密切相关。多数情况下，面向连接的协议做了许多工作，能确保数据的可靠性和次序性。而无连接的协议不必去验证数据完整性，不必确认收到的数据，也不必考虑数据的次序，因而简单、快速得多。</p> <h2 id="_6-高效的用户数据报协议-udp"><a href="#_6-高效的用户数据报协议-udp" class="header-anchor">#</a> 6.高效的用户数据报协议(UDP)</h2> <p><a href="/blog/network/udp/udp">UDP</a>的详细介绍</p> <h2 id="_7-可靠的传输控制协议-tcp"><a href="#_7-可靠的传输控制协议-tcp" class="header-anchor">#</a> 7.可靠的传输控制协议(TCP)</h2> <p><a href="/blog/network/tcp/tcp.html">TCP</a>的详细介绍</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/trefoils/Blog/edit/master/docs/study/network/basic/basic.md" target="_blank" rel="noopener noreferrer">在 Github 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">8/23/2020, 2:33:54 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/study/network/cs-mode/cs-mode.html">
        客户机/服务器交互模式(C/S)
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f41c39d2.js" defer></script><script src="/assets/js/2.0f0c28b9.js" defer></script><script src="/assets/js/32.a0a01885.js" defer></script>
  </body>
</html>
